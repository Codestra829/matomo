<?php
/**
 * Matomo - free/libre analytics platform
 *
 * @link https://matomo.org
 * @license http://www.gnu.org/licenses/gpl-3.0.html GPL v3 or later
 *
 */

namespace Piwik\Plugins\CoreConsole\Commands;

use Piwik\Container\StaticContainer;
use Piwik\Dependency\Prefixer;
use Piwik\Filesystem;
use Piwik\Http;
use Piwik\Plugin\ConsoleCommand;
use Piwik\Plugin\Manager;
use Matomo\Dependencies\Psr\Log\LoggerInterface;
use Matomo\Dependencies\Symfony\Component\Console\Input\InputInterface;
use Matomo\Dependencies\Symfony\Component\Console\Input\InputOption;
use Matomo\Dependencies\Symfony\Component\Console\Output\OutputInterface;

/**
 */
class PrefixDependency extends ConsoleCommand
{
    const PHP_SCOPER_VERSION = '0.17.5';
    // const PHP_SCOPER_URL = 'https://github.com/humbug/php-scoper/releases/download/' . self::PHP_SCOPER_VERSION . '/php-scoper.phar';
    // using forked version for now
    const PHP_SCOPER_URL = 'https://github.com/diosmosis/php-scoper/releases/download/included-ns3/php-scoper.phar';

    const PROXY_FILE_MARKER = '/* this file was generated by the development:prefix-dependency Matomo command */';
    const NAME = 'composer:prefix-dependency';

    protected function configure()
    {
        $this->setName(self::NAME);
        $this->setDescription('Prefix the namespace of every file in certain composer dependencies using php-scoper. Used to'
            . ' avoid collisions in environments where other third party software might use the same dependencies,'
            . ' like Matomo for Wordpress.');
        $this->addOption('php-scoper-path', null, InputOption::VALUE_REQUIRED,
            'Specify a custom path to php-scoper. If not supplied, the PHAR will be downloaded from github.');
        $this->addOption('composer-path', null, InputOption::VALUE_REQUIRED,
            'Path to composer. Required to generate a new autoloader.', getenv('COMPOSER_BINARY'));
        $this->addOption('keep-originals', null, InputOption::VALUE_NONE,
            'If supplied, keeps the original composer dependency files after prefixing (this may break autoloading).');
        $this->addOption('plugin', null, InputOption::VALUE_REQUIRED, 'Prefix dependencies for a specific plugin.');
    }

    /**
     * @var Prefixer
     */
    private $prefixer;

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        if ($this->isBeingInstalledAsComposerDependency()) {
            $output->writeln('Detected Matomo being installed as composer dependency, skipping prefixing.');
            $this->setUpPrefixRemovingAutoloader();
            return self::SUCCESS;
        }

        // symfony may try to log something after this command completes. If monolog is not loaded at that point,
        // it will fail since it is also prefixed. so we log a dummy message to make sure everything is properly loaded.
        StaticContainer::get(LoggerInterface::class)->info('-');

        $this->removePrefixRemovingAutoloader(); // can remain during development

        $composerPath = $this->getComposerPath($input);
        $phpScoperBinary = $this->downloadPhpScoperIfNeeded($input, $output);

        $prefixer = new Prefixer(StaticContainer::get(LoggerInterface::class));
        $this->prefixer = $prefixer;

        $prefixer->setPathToPhpScoper($phpScoperBinary);

        $plugin = $this->getPlugin($input);
        if ($plugin) {
            $output->writeln("Will process dependencies of plugin $plugin.");
            $prefixer->setComponentToPrefix($plugin);
            $prefixer->generatePhpScoperFileIfNotExists();
        } else {
            $prefixer->setComponentToPrefix('core');
        }

        $output->writeln("Will run php-scoper on the following dependencies: ["
            . implode(', ', $prefixer->getDependenciesToPrefix()) . ']');

        $output->writeln("<info>Prefixing dependencies...</info>");
        $prefixer->run();

        $output->writeln("");
        $output->writeln("<info>Regenerating autoloader...</info>");
        $this->generatePrefixedAutoloader($plugin, $prefixer->getDependenciesToPrefix(), $composerPath, $input, $output);
        $this->proxyOriginalComposerAutoloader($plugin, $output);

        $output->writeln("<info>Done.</info>");

        return self::SUCCESS;
    }

    private function downloadPhpScoperIfNeeded(InputInterface $input, OutputInterface $output)
    {
        $customPhpScoperPath = $input->getOption('php-scoper-path');
        if ($customPhpScoperPath) {
            return $customPhpScoperPath;
        }

        $outputPath = PIWIK_INCLUDE_PATH . '/php-scoper.phar';
        if (is_file($outputPath)) {
            $output->writeln("Found existing phar.");
            return $outputPath;
        }

        $output->writeln("Downloading php-scoper from github...");
        Http::fetchRemoteFile(self::PHP_SCOPER_URL, $outputPath);
        $output->writeln("...Finished.");

        return $outputPath;
    }

    private function getComposerPath(InputInterface $input)
    {
        $composerPath = $input->getOption('composer-path');
        if (empty($composerPath)) {
            throw new \InvalidArgumentException('The --composer-path option is required.');
        }

        if (!is_file($composerPath)) {
            throw new \InvalidArgumentException('--composer-path value "' . $composerPath . '" is not a file.');
        }

        return $composerPath;
    }

    private function generatePrefixedAutoloader($plugin, $dependenciesToPrefix, $composerPath, InputInterface $input, OutputInterface $output)
    {
        $basePath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin : PIWIK_INCLUDE_PATH;
        $prefixed = "$basePath/vendor/prefixed";

        if (!empty($dependenciesToPrefix)) {
            file_put_contents("$prefixed/composer.json", json_encode([
                'autoload' => [
                    'classmap' => [''],
                    'files' => $this->getFilesToAutoload($dependenciesToPrefix, $prefixed),
                ],
            ]));

            $output->writeln("Generating prefixed autoloader...");

            $composerCommand = escapeshellarg($composerPath) . " --working-dir=" . escapeshellarg($prefixed)
                . " dump-autoload -o --no-interaction";
            passthru($composerCommand, $returnCode);
            if ($returnCode) {
                throw new \Exception("Failed to invoke composer! Command was: $composerCommand");
            }

            Filesystem::remove("$prefixed/autoload.php");
            Filesystem::unlinkRecursive("$prefixed/composer", true);

            Filesystem::remove("$prefixed/composer.json");

            $removeOriginal = !$input->getOption('keep-originals');
            if ($removeOriginal) {
                foreach ($dependenciesToPrefix as $dependency) {
                    $vendorPath = "$basePath/vendor/$dependency";
                    Filesystem::unlinkRecursive($vendorPath, true);
                }
            }
        }

        $output->writeln("Regenerating unprefixed autoloader...");

        // composer does not recognize recursive symbolic links
        foreach (scandir(PIWIK_INCLUDE_PATH . '/tests/PHPUnit/proxy') as $item) {
            if ($item === '.' || $item === '..') {
                continue;
            }

            $path = PIWIK_INCLUDE_PATH . '/tests/PHPUnit/proxy/' . $item;
            if (is_link($path)) {
                unlink($path);
            }
        }

        // TODO: comment
        $existingAutoloadFiles = $this->getExistingAutoloadFilesWithoutPrefixed($basePath);

        $this->createDummyComposerJsonForPrefixed($basePath);
        try {
            $composerCommand = escapeshellarg($composerPath) . ' --working-dir=' . escapeshellarg($basePath)
                . " dump-autoload -o --no-interaction -q";
            passthru($composerCommand, $returnCode);
            if ($returnCode) {
                throw new \Exception("Failed to invoke composer! Command was: $composerCommand");
            }
        } finally {
            $this->removeDummyComposerJson($basePath);
        }

        $this->replaceAutoloadFiles($basePath, $existingAutoloadFiles);
    }

    private function proxyOriginalComposerAutoloader($plugin, OutputInterface $output)
    {
        $vendorPath = $plugin ? PIWIK_INCLUDE_PATH . '/plugins/' . $plugin . '/vendor' : PIWIK_VENDOR_PATH;

        $autoloadPath = $vendorPath . '/autoload.php';
        $originalAutoloadPath = $vendorPath . '/autoload_original.php';
        $proxyFileMarker = self::PROXY_FILE_MARKER;

        $proxyAutoloadContent = <<<EOF
<?php
$proxyFileMarker

\$originalLoader = require_once __DIR__ . DIRECTORY_SEPARATOR . 'autoload_original.php';

if (is_file(__DIR__ . '/prefixed/vendor/autoload.php')) {
    require_once __DIR__ . '/prefixed/vendor/autoload.php';
}

return \$originalLoader;
EOF;

        if ($this->isFileAutoloadProxy($autoloadPath)) {
            $output->writeln("<comment>Proxy autoload.php already exists, skipping generation.</comment>");
            return;
        }

        if (!is_file($autoloadPath)) {
            $output->writeln("<error>Cannot find original composer autoloader!</error>");
            return;
        }

        copy($autoloadPath, $originalAutoloadPath);
        file_put_contents($autoloadPath, $proxyAutoloadContent);
        $output->writeln("Generated proxy autoload.php.");
    }

    private function isFileAutoloadProxy($autoloadPath)
    {
        if (!is_file($autoloadPath)) {
            return false;
        }

        $contents = file_get_contents($autoloadPath);
        return strpos($contents, self::PROXY_FILE_MARKER) !== false;
    }

    private function getPlugin(InputInterface $input)
    {
        $plugin = $input->getOption('plugin');
        if (!$plugin) {
            return null;
        }

        if (!Manager::getInstance()->isPluginInFilesystem($plugin)) {
            throw new \InvalidArgumentException("Plugin $plugin does not exist!");
        }

        return $plugin;
    }

    private function isBeingInstalledAsComposerDependency()
    {
        $matomoVendorPath = PIWIK_INCLUDE_PATH . '/vendor';
        return !is_dir($matomoVendorPath);
    }

    private function setUpPrefixRemovingAutoloader()
    {
        $prefixAutoloadPath = PIWIK_INCLUDE_PATH . '/prefixAutoload.php';

        $content = '<?php return new \Piwik\Dependency\PrefixRemovingAutoloader();';
        file_put_contents($prefixAutoloadPath, $content);
    }

    private function removePrefixRemovingAutoloader()
    {
        $prefixAutoloadPath = PIWIK_INCLUDE_PATH . '/prefixAutoload.php';
        if (is_file($prefixAutoloadPath)) {
            unlink($prefixAutoloadPath);
        }
    }

    private function getFilesToAutoload($dependenciesToPrefix, string $prefixedFolderPath)
    {
        $files = [];

        foreach ($dependenciesToPrefix as $dependency) {
            $composerFile = $this->prefixer->getComposerJsonPath($prefixedFolderPath . '/' . $dependency);
            if (!is_file($composerFile)) {
                continue;
            }

            $contents = file_get_contents($composerFile);
            $contents = json_decode($contents, true);

            if (empty($contents['autoload']['files'])) {
                continue;
            }

            $dependencyFiles = $contents['autoload']['files'];
            $dependencyFiles = array_map(function ($p) use ($dependency) { return $dependency . '/' . $p; }, $dependencyFiles);

            $files = array_merge($files, $dependencyFiles);
        }

        return $files;
    }

    private function getExistingAutoloadFilesWithoutPrefixed(string $basePath)
    {
        $autoloadStatic = $basePath . '/vendor/composer/autoload_static.php';
        $autoloadStaticContents = file_get_contents($autoloadStatic);

        preg_match('/public static \$files.*?;/s', $autoloadStaticContents, $matches);
        $autoloadFiles = $matches[0];

        $autoloadFiles = explode("\n", $autoloadFiles);
        foreach ($autoloadFiles as $key => $line) {
            if (!preg_match("/'\/..'\s+\.\s+'(.*?)'/", $line, $matches)) {
                continue;
            }

            $relativePath = $matches[1];
            if (!is_file($basePath . '/vendor' . $relativePath)) { // dependency was prefixed
                unset($autoloadFiles[$key]);
            }
        }

        $autoloadFiles = implode("\n", $autoloadFiles);
        return $autoloadFiles;
    }

    private function replaceAutoloadFiles(string $basePath, string $existingAutoloadFiles)
    {
        $autoloadStatic = $basePath . '/vendor/composer/autoload_static.php';
        $autoloadStaticContents = file_get_contents($autoloadStatic);
        $autoloadStaticContents = preg_replace('/public static \$files.*?;/s', $existingAutoloadFiles, $autoloadStaticContents);
        file_put_contents($autoloadStatic, $autoloadStaticContents);
    }

    /**
     * TODO: document
     */
    private function createDummyComposerJsonForPrefixed(string $basePath)
    {
        $prefixedPath = $basePath . '/vendor/prefixed';

        foreach (scandir($prefixedPath) as $folder) {
            if ($folder == '.' || $folder == '..') {
                continue;
            }

            foreach (scandir($prefixedPath . '/' . $folder) as $subfolder) {
                if ($subfolder == '.' || $subfolder == '..') {
                    continue;
                }

                $prefixedComposerJsonPath = $prefixedPath . '/' . $folder . '/' . $subfolder . '/composer.json';
                if (!is_file($prefixedComposerJsonPath)) {
                    continue;
                }

                $composerJsonContents = file_get_contents($prefixedComposerJsonPath);
                $composerJsonContents = json_decode($composerJsonContents, true);

                $autoload = $composerJsonContents['autoload'];
                unset($composerJsonContents['autoload']);

                $composerJsonContents = json_encode($composerJsonContents, JSON_PRETTY_PRINT);

                $tempUnprefixedPath = $basePath . '/vendor/' . $folder . '/' . $subfolder;

                Filesystem::mkdir($tempUnprefixedPath);
                file_put_contents($tempUnprefixedPath . '/composer.json', $composerJsonContents);

                foreach ($autoload['classmap'] ?? [] as $classmapFolder) {
                    Filesystem::mkdir($tempUnprefixedPath . '/' . $classmapFolder);
                }
            }
        }
    }

    private function removeDummyComposerJson(string $basePath)
    {
        $prefixedPath = $basePath . '/vendor/prefixed';

        foreach (scandir($prefixedPath) as $folder) {
            if ($folder == '.' || $folder == '..') {
                continue;
            }

            foreach (scandir($prefixedPath . '/' . $folder) as $subfolder) {
                if ($subfolder == '.' || $subfolder == '..') {
                    continue;
                }

                $tempUnprefixedPath = $basePath . '/vendor/' . $folder . '/' . $subfolder;
                Filesystem::unlinkRecursive($tempUnprefixedPath, true);
            }
        }
    }
}
